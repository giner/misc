#!/usr/bin/env python3

#    create_web_cert
#
#    ----------------------------------------------------------------------
#    Copyright Â© 2018  Pellegrino Prevete
#
#    All rights reserved
#    ----------------------------------------------------------------------
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#


from subprocess import check_output as sh
from os import listdir as ls
from os.path import join as pjoin
from argparse import ArgumentParser

name = 'certbot_extra_formats'

def write_cert(app, certroot="/etc/letsencrypt/live/", verbose=False):
    """Combine and write let's encrypt certificates compatible with given application.

    Args:
        app (str): application that requests the certificate;
        certroot (str): where the letsencrypt certificates are (default: /etc/letsencrypt/live/);
        verbose (bool): extended output 
    Returns:
        True if the certificate has been written to certroot dir with 'app.pem' name, False otherwise.

    """
    out = {}
    if verbose: 
        print(app + ":")

    # Check certroot and obtain domains
    try:
        certroot = certroot if certroot.endswith("/") else certroot + "/"
        domains = ls(certroot)
    except FileNotFoundError as e:
        print("ERROR: certbot not configured or present:\n\t" + certroot + " not found or empty")
        domains = []

    for domain in domains:
        path = pjoin(certroot, domain)
        certname = pjoin(path, app + '.pem')
        certs = {pem:pjoin(path, pem) for pem in ls(path)}

        if app == "ejabberd":
            command = ['cat', ' ', certs['privkey.pem'], ' ', certs['fullchain.pem'], ' > ', certname]
        if app == "lighttpd":
            command = ['cat', ' ', certs['cert.pem'], ' ', certs['privkey.pem'], ' > ', name]
        else:
           print("ERROR: uknown application: " + app)
           return False 

        command = "".join(command)
        out[domain] = sh([command], shell=True)
        if out[domain] == b'':
            if verbose:
                print("\twriting " + domain)

    if all(out[k] == b'' for k in out.keys()):
            return True

if __name__ == "__main__":

    parser = ArgumentParser(description="Write a \"Let's Ecrypt\" certificate compatible with a given application")
    parser.add_argument('--verbose', dest='verbose', action='store_true', default=False, help="extended output")
    parser.add_argument('app', nargs='*', action='store', default=['lighttpd'], help="application that request the certificate")
    parser.add_argument('--certroot', dest='certroot', action='store', default="/etc/letsencrypt/live/", help="directory which contains the letsencrypt certificates")
    args = parser.parse_args()

    for app in args.app:
        written = write_cert(app, certroot=args.certroot, verbose=args.verbose)
